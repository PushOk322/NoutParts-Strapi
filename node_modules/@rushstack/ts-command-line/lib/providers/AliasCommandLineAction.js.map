{"version":3,"file":"AliasCommandLineAction.js","sourceRoot":"","sources":["../../src/providers/AliasCommandLineAction.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as argparse from 'argparse';\r\n\r\nimport { CommandLineAction } from './CommandLineAction';\r\nimport { CommandLineParameterKind, type CommandLineParameter } from '../parameters/BaseClasses';\r\nimport type { ICommandLineParserData, IRegisterDefinedParametersState } from './CommandLineParameterProvider';\r\nimport type { ICommandLineParserOptions } from './CommandLineParser';\r\nimport type { CommandLineChoiceParameter } from '../parameters/CommandLineChoiceParameter';\r\nimport type { CommandLineFlagParameter } from '../parameters/CommandLineFlagParameter';\r\nimport type { CommandLineStringParameter } from '../parameters/CommandLineStringParameter';\r\nimport type { CommandLineIntegerParameter } from '../parameters/CommandLineIntegerParameter';\r\nimport type { CommandLineChoiceListParameter } from '../parameters/CommandLineChoiceListParameter';\r\nimport type { CommandLineIntegerListParameter } from '../parameters/CommandLineIntegerListParameter';\r\n\r\n/**\r\n * Options for the AliasCommandLineAction constructor.\r\n * @public\r\n */\r\nexport interface IAliasCommandLineActionOptions {\r\n  /**\r\n   * The name of your tool when invoked from the command line. Used for generating help text.\r\n   */\r\n  toolFilename: string;\r\n\r\n  /**\r\n   * The name of the alias.  For example, if the tool is called \"example\",\r\n   * then the \"build\" alias might be invoked as: \"example build -q --some-other-option\"\r\n   */\r\n  aliasName: string;\r\n\r\n  /**\r\n   * A list of default parameters to pass to the target action.\r\n   */\r\n  defaultParameters?: string[];\r\n\r\n  /**\r\n   * The action that this alias invokes.\r\n   */\r\n  targetAction: CommandLineAction;\r\n}\r\n\r\n/**\r\n * Represents a sub-command that is part of the CommandLineParser command line.\r\n * The sub-command is an alias for another existing action.\r\n *\r\n * The alias name should be comprised of lower case words separated by hyphens\r\n * or colons. The name should include an English verb (e.g. \"deploy\"). Use a\r\n * hyphen to separate words (e.g. \"upload-docs\").\r\n *\r\n * @public\r\n */\r\nexport class AliasCommandLineAction extends CommandLineAction {\r\n  /**\r\n   * The action that this alias invokes.\r\n   */\r\n  public readonly targetAction: CommandLineAction;\r\n\r\n  /**\r\n   * A list of default arguments to pass to the target action.\r\n   */\r\n  public readonly defaultParameters: ReadonlyArray<string>;\r\n\r\n  private _parameterKeyMap: Map<string, string> = new Map();\r\n\r\n  public constructor(options: IAliasCommandLineActionOptions) {\r\n    const toolFilename: string = options.toolFilename;\r\n    const targetActionName: string = options.targetAction.actionName;\r\n    const defaultParametersString: string = (options.defaultParameters || []).join(' ');\r\n    const summary: string = `An alias for \"${toolFilename} ${targetActionName}${\r\n      defaultParametersString ? ` ${defaultParametersString}` : ''\r\n    }\".`;\r\n\r\n    super({\r\n      actionName: options.aliasName,\r\n      summary,\r\n      documentation:\r\n        `${summary} For more information on the aliased command, use ` +\r\n        `\"${toolFilename} ${targetActionName} --help\".`\r\n    });\r\n\r\n    this.targetAction = options.targetAction;\r\n    this.defaultParameters = options.defaultParameters || [];\r\n  }\r\n\r\n  /** @internal */\r\n  public _registerDefinedParameters(state: IRegisterDefinedParametersState): void {\r\n    /* override */\r\n    // All parameters are going to be defined by the target action. Re-use the target action parameters\r\n    // for this action.\r\n    for (const parameter of this.targetAction.parameters) {\r\n      let aliasParameter: CommandLineParameter;\r\n      const nameOptions: { parameterLongName: string; parameterShortName: string | undefined } = {\r\n        parameterLongName: parameter.longName,\r\n        parameterShortName: parameter.shortName\r\n      };\r\n      switch (parameter.kind) {\r\n        case CommandLineParameterKind.Choice:\r\n          const choiceParameter: CommandLineChoiceParameter = parameter as CommandLineChoiceParameter;\r\n          aliasParameter = this.defineChoiceParameter({\r\n            ...nameOptions,\r\n            ...choiceParameter,\r\n            alternatives: ([] as string[]).concat(choiceParameter.alternatives)\r\n          });\r\n          break;\r\n        case CommandLineParameterKind.ChoiceList:\r\n          const choiceListParameter: CommandLineChoiceListParameter =\r\n            parameter as CommandLineChoiceListParameter;\r\n          aliasParameter = this.defineChoiceListParameter({\r\n            ...nameOptions,\r\n            ...choiceListParameter,\r\n            alternatives: ([] as string[]).concat(choiceListParameter.alternatives)\r\n          });\r\n          break;\r\n        case CommandLineParameterKind.Flag:\r\n          const flagParameter: CommandLineFlagParameter = parameter as CommandLineFlagParameter;\r\n          aliasParameter = this.defineFlagParameter({ ...nameOptions, ...flagParameter });\r\n          break;\r\n        case CommandLineParameterKind.Integer:\r\n          const integerParameter: CommandLineIntegerParameter = parameter as CommandLineIntegerParameter;\r\n          aliasParameter = this.defineIntegerParameter({ ...nameOptions, ...integerParameter });\r\n          break;\r\n        case CommandLineParameterKind.IntegerList:\r\n          const integerListParameter: CommandLineIntegerListParameter =\r\n            parameter as CommandLineIntegerListParameter;\r\n          aliasParameter = this.defineIntegerListParameter({ ...nameOptions, ...integerListParameter });\r\n          break;\r\n        case CommandLineParameterKind.String:\r\n          const stringParameter: CommandLineStringParameter = parameter as CommandLineStringParameter;\r\n          aliasParameter = this.defineStringParameter({ ...nameOptions, ...stringParameter });\r\n          break;\r\n        case CommandLineParameterKind.StringList:\r\n          const stringListParameter: CommandLineStringParameter = parameter as CommandLineStringParameter;\r\n          aliasParameter = this.defineStringListParameter({ ...nameOptions, ...stringListParameter });\r\n          break;\r\n        default:\r\n          throw new Error(`Unsupported parameter kind: ${parameter.kind}`);\r\n      }\r\n\r\n      // We know the parserKey is defined because the underlying _defineParameter method sets it,\r\n      // and all parameters that we have access to have already been defined.\r\n      this._parameterKeyMap.set(aliasParameter._parserKey!, parameter._parserKey!);\r\n    }\r\n\r\n    // We also need to register the remainder parameter if the target action has one. The parser\r\n    // key for this parameter is constant.\r\n    if (this.targetAction.remainder) {\r\n      this.defineCommandLineRemainder(this.targetAction.remainder);\r\n      this._parameterKeyMap.set(argparse.Const.REMAINDER, argparse.Const.REMAINDER);\r\n    }\r\n\r\n    // Finally, register the parameters with the parser. We need to make sure that the target action\r\n    // is registered, since we need to re-use its parameters, and ambiguous parameters are discovered\r\n    // during registration. This will no-op if the target action is already registered.\r\n    this.targetAction._registerDefinedParameters(state);\r\n    super._registerDefinedParameters(state);\r\n\r\n    // We need to re-map the ambiguous parameters after they are defined by calling\r\n    // super._registerDefinedParameters()\r\n    for (const [ambiguousParameterName, parserKey] of this._ambiguousParameterParserKeysByName) {\r\n      const targetParserKey: string | undefined =\r\n        this.targetAction._ambiguousParameterParserKeysByName.get(ambiguousParameterName);\r\n\r\n      // If we have a mapping for the specified key, then use it. Otherwise, use the key as-is.\r\n      if (targetParserKey) {\r\n        this._parameterKeyMap.set(parserKey, targetParserKey);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * This is called internally by CommandLineParser.execute()\r\n   * @internal\r\n   */\r\n  public _processParsedData(parserOptions: ICommandLineParserOptions, data: ICommandLineParserData): void {\r\n    // Re-map the parsed data to the target action's parameters and execute the target action processor.\r\n    const targetData: ICommandLineParserData = {\r\n      action: this.targetAction.actionName,\r\n      aliasAction: data.action,\r\n      aliasDocumentation: this.documentation\r\n    };\r\n    for (const [key, value] of Object.entries(data)) {\r\n      // If we have a mapping for the specified key, then use it. Otherwise, use the key as-is.\r\n      // Skip over the action key though, since we've already re-mapped it to \"aliasAction\"\r\n      if (key === 'action') {\r\n        continue;\r\n      }\r\n      const targetKey: string | undefined = this._parameterKeyMap.get(key);\r\n      targetData[targetKey ?? key] = value;\r\n    }\r\n    this.targetAction._processParsedData(parserOptions, targetData);\r\n  }\r\n\r\n  /**\r\n   * Executes the target action.\r\n   */\r\n  protected async onExecute(): Promise<void> {\r\n    await this.targetAction._execute();\r\n  }\r\n}\r\n"]}