{"version":3,"file":"CommandLineParameterProvider.js","sourceRoot":"","sources":["../../src/providers/CommandLineParameterProvider.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport * as argparse from 'argparse';\r\n\r\nimport type {\r\n  ICommandLineChoiceDefinition,\r\n  ICommandLineChoiceListDefinition,\r\n  ICommandLineIntegerDefinition,\r\n  ICommandLineIntegerListDefinition,\r\n  ICommandLineFlagDefinition,\r\n  ICommandLineStringDefinition,\r\n  ICommandLineStringListDefinition,\r\n  ICommandLineRemainderDefinition\r\n} from '../parameters/CommandLineDefinition';\r\nimport type { ICommandLineParserOptions } from './CommandLineParser';\r\nimport {\r\n  type CommandLineParameter,\r\n  type CommandLineParameterWithArgument,\r\n  CommandLineParameterKind\r\n} from '../parameters/BaseClasses';\r\nimport { CommandLineChoiceParameter } from '../parameters/CommandLineChoiceParameter';\r\nimport { CommandLineChoiceListParameter } from '../parameters/CommandLineChoiceListParameter';\r\nimport { CommandLineIntegerParameter } from '../parameters/CommandLineIntegerParameter';\r\nimport { CommandLineIntegerListParameter } from '../parameters/CommandLineIntegerListParameter';\r\nimport { CommandLineFlagParameter } from '../parameters/CommandLineFlagParameter';\r\nimport { CommandLineStringParameter } from '../parameters/CommandLineStringParameter';\r\nimport { CommandLineStringListParameter } from '../parameters/CommandLineStringListParameter';\r\nimport { CommandLineRemainder } from '../parameters/CommandLineRemainder';\r\nimport { SCOPING_PARAMETER_GROUP } from '../Constants';\r\nimport { CommandLineParserExitError } from './CommandLineParserExitError';\r\n\r\n/**\r\n * The result containing the parsed paramter long name and scope. Returned when calling\r\n * {@link CommandLineParameterProvider.parseScopedLongName}.\r\n *\r\n * @public\r\n */\r\nexport interface IScopedLongNameParseResult {\r\n  /**\r\n   * The long name parsed from the scoped long name, e.g. \"--my-scope:my-parameter\" -\\> \"--my-parameter\"\r\n   */\r\n  longName: string;\r\n\r\n  /**\r\n   * The scope parsed from the scoped long name or undefined if no scope was found,\r\n   * e.g. \"--my-scope:my-parameter\" -\\> \"my-scope\"\r\n   */\r\n  scope: string | undefined;\r\n}\r\n\r\n/**\r\n * An object containing the state of the\r\n *\r\n * @internal\r\n */\r\nexport interface IRegisterDefinedParametersState {\r\n  /**\r\n   * A set of all defined parameter names registered by parent {@link CommandLineParameterProvider}\r\n   * objects.\r\n   */\r\n  parentParameterNames: Set<string>;\r\n}\r\n\r\n/**\r\n * This is the argparse result data object\r\n * @internal\r\n */\r\nexport interface ICommandLineParserData {\r\n  action: string;\r\n  aliasAction?: string;\r\n  aliasDocumentation?: string;\r\n  [key: string]: any; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n}\r\n\r\nconst SCOPE_GROUP_NAME: string = 'scope';\r\nconst LONG_NAME_GROUP_NAME: string = 'longName';\r\nconst POSSIBLY_SCOPED_LONG_NAME_REGEXP: RegExp =\r\n  /^--((?<scope>[a-z0-9]+(-[a-z0-9]+)*):)?(?<longName>[a-z0-9]+((-[a-z0-9]+)+)?)$/;\r\n\r\n/**\r\n * This is the common base class for CommandLineAction and CommandLineParser\r\n * that provides functionality for defining command-line parameters.\r\n *\r\n * @public\r\n */\r\nexport abstract class CommandLineParameterProvider {\r\n  private static _keyCounter: number = 0;\r\n\r\n  /** @internal */\r\n  public readonly _ambiguousParameterParserKeysByName: Map<string, string>;\r\n  /** @internal */\r\n  protected readonly _registeredParameterParserKeysByName: Map<string, string>;\r\n\r\n  private readonly _parameters: CommandLineParameter[];\r\n  private readonly _parametersByLongName: Map<string, CommandLineParameter[]>;\r\n  private readonly _parametersByShortName: Map<string, CommandLineParameter[]>;\r\n  private readonly _parameterGroupsByName: Map<\r\n    string | typeof SCOPING_PARAMETER_GROUP,\r\n    argparse.ArgumentGroup\r\n  >;\r\n  private _parametersHaveBeenRegistered: boolean;\r\n  private _parametersHaveBeenProcessed: boolean;\r\n  private _remainder: CommandLineRemainder | undefined;\r\n\r\n  /** @internal */\r\n  // Third party code should not inherit subclasses or call this constructor\r\n  public constructor() {\r\n    this._parameters = [];\r\n    this._parametersByLongName = new Map();\r\n    this._parametersByShortName = new Map();\r\n    this._parameterGroupsByName = new Map();\r\n    this._ambiguousParameterParserKeysByName = new Map();\r\n    this._registeredParameterParserKeysByName = new Map();\r\n    this._parametersHaveBeenRegistered = false;\r\n    this._parametersHaveBeenProcessed = false;\r\n  }\r\n\r\n  /**\r\n   * Returns a collection of the parameters that were defined for this object.\r\n   */\r\n  public get parameters(): ReadonlyArray<CommandLineParameter> {\r\n    return this._parameters;\r\n  }\r\n\r\n  /**\r\n   * Informs the caller if the argparse data has been processed into parameters.\r\n   */\r\n  public get parametersProcessed(): boolean {\r\n    return this._parametersHaveBeenProcessed;\r\n  }\r\n\r\n  /**\r\n   * If {@link CommandLineParameterProvider.defineCommandLineRemainder} was called,\r\n   * this object captures any remaining command line arguments after the recognized portion.\r\n   */\r\n  public get remainder(): CommandLineRemainder | undefined {\r\n    return this._remainder;\r\n  }\r\n\r\n  /**\r\n   * Defines a command-line parameter whose value must be a string from a fixed set of\r\n   * allowable choices (similar to an enum).\r\n   *\r\n   * @remarks\r\n   * Example of a choice parameter:\r\n   * ```\r\n   * example-tool --log-level warn\r\n   * ```\r\n   */\r\n  public defineChoiceParameter(definition: ICommandLineChoiceDefinition): CommandLineChoiceParameter {\r\n    const parameter: CommandLineChoiceParameter = new CommandLineChoiceParameter(definition);\r\n    this._defineParameter(parameter);\r\n    return parameter;\r\n  }\r\n\r\n  /**\r\n   * Returns the CommandLineChoiceParameter with the specified long name.\r\n   * @remarks\r\n   * This method throws an exception if the parameter is not defined.\r\n   */\r\n  public getChoiceParameter(parameterLongName: string, parameterScope?: string): CommandLineChoiceParameter {\r\n    return this._getParameter(parameterLongName, CommandLineParameterKind.Choice, parameterScope);\r\n  }\r\n\r\n  /**\r\n   * Defines a command-line parameter whose value must be a string from a fixed set of\r\n   * allowable choices (similar to an enum). The parameter can be specified multiple times to\r\n   * build a list.\r\n   *\r\n   * @remarks\r\n   * Example of a choice list parameter:\r\n   * ```\r\n   * example-tool --allow-color red --allow-color green\r\n   * ```\r\n   */\r\n  public defineChoiceListParameter(\r\n    definition: ICommandLineChoiceListDefinition\r\n  ): CommandLineChoiceListParameter {\r\n    const parameter: CommandLineChoiceListParameter = new CommandLineChoiceListParameter(definition);\r\n    this._defineParameter(parameter);\r\n    return parameter;\r\n  }\r\n\r\n  /**\r\n   * Returns the CommandLineChoiceListParameter with the specified long name.\r\n   * @remarks\r\n   * This method throws an exception if the parameter is not defined.\r\n   */\r\n  public getChoiceListParameter(\r\n    parameterLongName: string,\r\n    parameterScope?: string\r\n  ): CommandLineChoiceListParameter {\r\n    return this._getParameter(parameterLongName, CommandLineParameterKind.ChoiceList, parameterScope);\r\n  }\r\n\r\n  /**\r\n   * Defines a command-line switch whose boolean value is true if the switch is provided,\r\n   * and false otherwise.\r\n   *\r\n   * @remarks\r\n   * Example usage of a flag parameter:\r\n   * ```\r\n   * example-tool --debug\r\n   * ```\r\n   */\r\n  public defineFlagParameter(definition: ICommandLineFlagDefinition): CommandLineFlagParameter {\r\n    const parameter: CommandLineFlagParameter = new CommandLineFlagParameter(definition);\r\n    this._defineParameter(parameter);\r\n    return parameter;\r\n  }\r\n\r\n  /**\r\n   * Returns the CommandLineFlagParameter with the specified long name.\r\n   * @remarks\r\n   * This method throws an exception if the parameter is not defined.\r\n   */\r\n  public getFlagParameter(parameterLongName: string, parameterScope?: string): CommandLineFlagParameter {\r\n    return this._getParameter(parameterLongName, CommandLineParameterKind.Flag, parameterScope);\r\n  }\r\n\r\n  /**\r\n   * Defines a command-line parameter whose argument is an integer.\r\n   *\r\n   * @remarks\r\n   * Example usage of an integer parameter:\r\n   * ```\r\n   * example-tool --max-attempts 5\r\n   * ```\r\n   */\r\n  public defineIntegerParameter(definition: ICommandLineIntegerDefinition): CommandLineIntegerParameter {\r\n    const parameter: CommandLineIntegerParameter = new CommandLineIntegerParameter(definition);\r\n    this._defineParameter(parameter);\r\n    return parameter;\r\n  }\r\n\r\n  /**\r\n   * Returns the CommandLineIntegerParameter with the specified long name.\r\n   * @remarks\r\n   * This method throws an exception if the parameter is not defined.\r\n   */\r\n  public getIntegerParameter(\r\n    parameterLongName: string,\r\n    parameterScope?: string\r\n  ): CommandLineIntegerParameter {\r\n    return this._getParameter(parameterLongName, CommandLineParameterKind.Integer, parameterScope);\r\n  }\r\n\r\n  /**\r\n   * Defines a command-line parameter whose argument is an integer. The parameter can be specified\r\n   * multiple times to build a list.\r\n   *\r\n   * @remarks\r\n   * Example usage of an integer list parameter:\r\n   * ```\r\n   * example-tool --avoid 4 --avoid 13\r\n   * ```\r\n   */\r\n  public defineIntegerListParameter(\r\n    definition: ICommandLineIntegerListDefinition\r\n  ): CommandLineIntegerListParameter {\r\n    const parameter: CommandLineIntegerListParameter = new CommandLineIntegerListParameter(definition);\r\n    this._defineParameter(parameter);\r\n    return parameter;\r\n  }\r\n\r\n  /**\r\n   * Returns the CommandLineIntegerParameter with the specified long name.\r\n   * @remarks\r\n   * This method throws an exception if the parameter is not defined.\r\n   */\r\n  public getIntegerListParameter(\r\n    parameterLongName: string,\r\n    parameterScope?: string\r\n  ): CommandLineIntegerListParameter {\r\n    return this._getParameter(parameterLongName, CommandLineParameterKind.IntegerList, parameterScope);\r\n  }\r\n\r\n  /**\r\n   * Defines a command-line parameter whose argument is a single text string.\r\n   *\r\n   * @remarks\r\n   * Example usage of a string parameter:\r\n   * ```\r\n   * example-tool --message \"Hello, world!\"\r\n   * ```\r\n   */\r\n  public defineStringParameter(definition: ICommandLineStringDefinition): CommandLineStringParameter {\r\n    const parameter: CommandLineStringParameter = new CommandLineStringParameter(definition);\r\n    this._defineParameter(parameter);\r\n    return parameter;\r\n  }\r\n\r\n  /**\r\n   * Returns the CommandLineStringParameter with the specified long name.\r\n   * @remarks\r\n   * This method throws an exception if the parameter is not defined.\r\n   */\r\n  public getStringParameter(parameterLongName: string, parameterScope?: string): CommandLineStringParameter {\r\n    return this._getParameter(parameterLongName, CommandLineParameterKind.String, parameterScope);\r\n  }\r\n\r\n  /**\r\n   * Defines a command-line parameter whose argument is a single text string.  The parameter can be\r\n   * specified multiple times to build a list.\r\n   *\r\n   * @remarks\r\n   * Example usage of a string list parameter:\r\n   * ```\r\n   * example-tool --add file1.txt --add file2.txt --add file3.txt\r\n   * ```\r\n   */\r\n  public defineStringListParameter(\r\n    definition: ICommandLineStringListDefinition\r\n  ): CommandLineStringListParameter {\r\n    const parameter: CommandLineStringListParameter = new CommandLineStringListParameter(definition);\r\n    this._defineParameter(parameter);\r\n    return parameter;\r\n  }\r\n\r\n  /**\r\n   * Defines a rule that captures any remaining command line arguments after the recognized portion.\r\n   *\r\n   * @remarks\r\n   * This feature is useful for commands that pass their arguments along to an external tool, relying on\r\n   * that tool to perform validation.  (It could also be used to parse parameters without any validation\r\n   * or documentation, but that is not recommended.)\r\n   *\r\n   * Example of capturing the remainder after an optional flag parameter.\r\n   * ```\r\n   * example-tool --my-flag this is the remainder\r\n   * ```\r\n   *\r\n   * In the \"--help\" documentation, the remainder rule will be represented as \"...\".\r\n   */\r\n  public defineCommandLineRemainder(definition: ICommandLineRemainderDefinition): CommandLineRemainder {\r\n    if (this._remainder) {\r\n      throw new Error('defineRemainingArguments() has already been called for this provider');\r\n    }\r\n    this._remainder = new CommandLineRemainder(definition);\r\n    return this._remainder;\r\n  }\r\n\r\n  /**\r\n   * Returns the CommandLineStringListParameter with the specified long name.\r\n   * @remarks\r\n   * This method throws an exception if the parameter is not defined.\r\n   */\r\n  public getStringListParameter(\r\n    parameterLongName: string,\r\n    parameterScope?: string\r\n  ): CommandLineStringListParameter {\r\n    return this._getParameter(parameterLongName, CommandLineParameterKind.StringList, parameterScope);\r\n  }\r\n\r\n  /**\r\n   * Generates the command-line help text.\r\n   */\r\n  public renderHelpText(): string {\r\n    const initialState: IRegisterDefinedParametersState = {\r\n      parentParameterNames: new Set()\r\n    };\r\n    this._registerDefinedParameters(initialState);\r\n    return this._getArgumentParser().formatHelp();\r\n  }\r\n\r\n  /**\r\n   * Generates the command-line usage text.\r\n   */\r\n  public renderUsageText(): string {\r\n    const initialState: IRegisterDefinedParametersState = {\r\n      parentParameterNames: new Set()\r\n    };\r\n    this._registerDefinedParameters(initialState);\r\n    return this._getArgumentParser().formatUsage();\r\n  }\r\n\r\n  /**\r\n   * Returns a object which maps the long name of each parameter in this.parameters\r\n   * to the stringified form of its value. This is useful for logging telemetry, but\r\n   * it is not the proper way of accessing parameters or their values.\r\n   */\r\n  public getParameterStringMap(): Record<string, string> {\r\n    const parameterMap: Record<string, string> = {};\r\n    for (const parameter of this.parameters) {\r\n      const parameterName: string = parameter.scopedLongName || parameter.longName;\r\n      switch (parameter.kind) {\r\n        case CommandLineParameterKind.Flag:\r\n        case CommandLineParameterKind.Choice:\r\n        case CommandLineParameterKind.String:\r\n        case CommandLineParameterKind.Integer:\r\n          parameterMap[parameterName] = JSON.stringify(\r\n            (\r\n              parameter as\r\n                | CommandLineFlagParameter\r\n                | CommandLineIntegerParameter\r\n                | CommandLineChoiceParameter\r\n                | CommandLineStringParameter\r\n            ).value\r\n          );\r\n          break;\r\n        case CommandLineParameterKind.StringList:\r\n        case CommandLineParameterKind.IntegerList:\r\n        case CommandLineParameterKind.ChoiceList:\r\n          const arrayValue: ReadonlyArray<string | number> | undefined = (\r\n            parameter as\r\n              | CommandLineIntegerListParameter\r\n              | CommandLineStringListParameter\r\n              | CommandLineChoiceListParameter\r\n          ).values;\r\n          parameterMap[parameterName] = arrayValue ? arrayValue.join(',') : '';\r\n          break;\r\n      }\r\n    }\r\n    return parameterMap;\r\n  }\r\n\r\n  /**\r\n   * Returns an object with the parsed scope (if present) and the long name of the parameter.\r\n   */\r\n  public parseScopedLongName(scopedLongName: string): IScopedLongNameParseResult {\r\n    const result: RegExpExecArray | null = POSSIBLY_SCOPED_LONG_NAME_REGEXP.exec(scopedLongName);\r\n    if (!result || !result.groups) {\r\n      throw new Error(`The parameter long name \"${scopedLongName}\" is not valid.`);\r\n    }\r\n    return {\r\n      longName: `--${result.groups[LONG_NAME_GROUP_NAME]}`,\r\n      scope: result.groups[SCOPE_GROUP_NAME]\r\n    };\r\n  }\r\n\r\n  /** @internal */\r\n  public _registerDefinedParameters(state: IRegisterDefinedParametersState): void {\r\n    if (this._parametersHaveBeenRegistered) {\r\n      // We prevent new parameters from being defined after the first call to _registerDefinedParameters,\r\n      // so we can already ensure that all parameters were registered.\r\n      return;\r\n    }\r\n\r\n    // First, loop through all parameters with short names. If there are any duplicates, disable the short names\r\n    // since we can't prefix scopes to short names in order to deduplicate them. The duplicate short names will\r\n    // be reported as errors if the user attempts to use them.\r\n    const parametersWithDuplicateShortNames: Set<CommandLineParameter> = new Set();\r\n    for (const [shortName, shortNameParameters] of this._parametersByShortName.entries()) {\r\n      if (shortNameParameters.length > 1) {\r\n        for (const parameter of shortNameParameters) {\r\n          this._defineAmbiguousParameter(shortName);\r\n          parametersWithDuplicateShortNames.add(parameter);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Then, loop through all parameters and register them. If there are any duplicates, ensure that they have\r\n    // provided a scope and register them with the scope. The duplicate long names will be reported as an error\r\n    // if the user attempts to use them.\r\n    for (const longNameParameters of this._parametersByLongName.values()) {\r\n      const useScopedLongName: boolean = longNameParameters.length > 1;\r\n      for (const parameter of longNameParameters) {\r\n        if (useScopedLongName) {\r\n          if (!parameter.parameterScope) {\r\n            throw new Error(\r\n              `The parameter \"${parameter.longName}\" is defined multiple times with the same long name. ` +\r\n                'Parameters with the same long name must define a scope.'\r\n            );\r\n          }\r\n          this._defineAmbiguousParameter(parameter.longName);\r\n        }\r\n\r\n        const ignoreShortName: boolean = parametersWithDuplicateShortNames.has(parameter);\r\n        this._registerParameter(parameter, useScopedLongName, ignoreShortName);\r\n      }\r\n    }\r\n\r\n    // Register the existing parameters as ambiguous parameters. These are generally provided by the\r\n    // parent action.\r\n    const { parentParameterNames } = state;\r\n    for (const parentParameterName of parentParameterNames) {\r\n      this._defineAmbiguousParameter(parentParameterName);\r\n    }\r\n\r\n    // We also need to loop through the defined ambiguous parameters and register them. These will be reported\r\n    // as errors if the user attempts to use them.\r\n    for (const [ambiguousParameterName, parserKey] of this._ambiguousParameterParserKeysByName) {\r\n      // Only register the ambiguous parameter if it hasn't already been registered. We will still handle these\r\n      // already-registered parameters as ambiguous, but by avoiding registering again, we will defer errors\r\n      // until the user actually attempts to use the parameter.\r\n      if (!this._registeredParameterParserKeysByName.has(ambiguousParameterName)) {\r\n        this._registerAmbiguousParameter(ambiguousParameterName, parserKey);\r\n      }\r\n    }\r\n\r\n    // Need to add the remainder parameter last\r\n    if (this._remainder) {\r\n      const argparseOptions: argparse.ArgumentOptions = {\r\n        help: this._remainder.description,\r\n        nargs: argparse.Const.REMAINDER,\r\n        metavar: '\"...\"'\r\n      };\r\n\r\n      this._getArgumentParser().addArgument(argparse.Const.REMAINDER, argparseOptions);\r\n    }\r\n\r\n    this._parametersHaveBeenRegistered = true;\r\n  }\r\n\r\n  /**\r\n   * The child class should implement this hook to define its command-line parameters,\r\n   * e.g. by calling defineFlagParameter().\r\n   */\r\n  protected onDefineParameters?(): void;\r\n\r\n  /**\r\n   * Retrieves the argparse object.\r\n   * @internal\r\n   */\r\n  protected abstract _getArgumentParser(): argparse.ArgumentParser;\r\n\r\n  /** @internal */\r\n  protected _processParsedData(parserOptions: ICommandLineParserOptions, data: ICommandLineParserData): void {\r\n    if (!this._parametersHaveBeenRegistered) {\r\n      throw new Error('Parameters have not been registered');\r\n    }\r\n\r\n    if (this._parametersHaveBeenProcessed) {\r\n      throw new Error('Command Line Parser Data was already processed');\r\n    }\r\n\r\n    // Search for any ambiguous parameters and throw an error if any are found\r\n    for (const [parameterName, parserKey] of this._ambiguousParameterParserKeysByName) {\r\n      if (data[parserKey]) {\r\n        // When the parser key matches the actually registered parameter, we know that this is an ambiguous\r\n        // parameter sourced from the parent action or tool\r\n        if (this._registeredParameterParserKeysByName.get(parameterName) === parserKey) {\r\n          this._throwParserExitError(parserOptions, data, 1, `Ambiguous option: \"${parameterName}\".`);\r\n        }\r\n\r\n        // Determine if the ambiguous parameter is a short name or a long name, since the process of finding\r\n        // the non-ambiguous name is different for each.\r\n        const duplicateShortNameParameters: CommandLineParameter[] | undefined =\r\n          this._parametersByShortName.get(parameterName);\r\n        if (duplicateShortNameParameters) {\r\n          // We also need to make sure we get the non-ambiguous long name for the parameter, since it is\r\n          // possible for that the long name is ambiguous as well.\r\n          const nonAmbiguousLongNames: string[] = [];\r\n          for (const parameter of duplicateShortNameParameters) {\r\n            const matchingLongNameParameters: CommandLineParameter[] | undefined =\r\n              this._parametersByLongName.get(parameter.longName);\r\n            if (!matchingLongNameParameters?.length) {\r\n              // This should never happen\r\n              throw new Error(\r\n                `Unable to find long name parameters for ambiguous short name parameter \"${parameterName}\".`\r\n              );\r\n            }\r\n            // If there is more than one matching long name parameter, then we know that we need to use the\r\n            // scoped long name for the parameter. The scoped long name should always be provided.\r\n            if (matchingLongNameParameters.length > 1) {\r\n              if (!parameter.scopedLongName) {\r\n                // This should never happen\r\n                throw new Error(\r\n                  `Unable to find scoped long name for ambiguous short name parameter \"${parameterName}\".`\r\n                );\r\n              }\r\n              nonAmbiguousLongNames.push(parameter.scopedLongName);\r\n            } else {\r\n              nonAmbiguousLongNames.push(parameter.longName);\r\n            }\r\n          }\r\n\r\n          // Throw an error including the non-ambiguous long names for the parameters that have the ambiguous\r\n          // short name, ex.\r\n          // Error: Ambiguous option \"-p\" could match \"--param1\", \"--param2\"\r\n          this._throwParserExitError(\r\n            parserOptions,\r\n            data,\r\n            1,\r\n            `Ambiguous option: \"${parameterName}\" could match ${nonAmbiguousLongNames.join(', ')}.`\r\n          );\r\n        }\r\n\r\n        const duplicateLongNameParameters: CommandLineParameter[] | undefined =\r\n          this._parametersByLongName.get(parameterName);\r\n        if (duplicateLongNameParameters) {\r\n          const nonAmbiguousLongNames: string[] = duplicateLongNameParameters.map(\r\n            (p: CommandLineParameter) => {\r\n              // The scoped long name should always be provided\r\n              if (!p.scopedLongName) {\r\n                // This should never happen\r\n                throw new Error(\r\n                  `Unable to find scoped long name for ambiguous long name parameter \"${parameterName}\".`\r\n                );\r\n              }\r\n              return p.scopedLongName;\r\n            }\r\n          );\r\n\r\n          // Throw an error including the non-ambiguous scoped long names for the parameters that have the\r\n          // ambiguous long name, ex.\r\n          // Error: Ambiguous option: \"--param\" could match --scope1:param, --scope2:param\r\n          this._throwParserExitError(\r\n            parserOptions,\r\n            data,\r\n            1,\r\n            `Ambiguous option: \"${parameterName}\" could match ${nonAmbiguousLongNames.join(', ')}.`\r\n          );\r\n        }\r\n\r\n        // This shouldn't happen, but we also shouldn't allow the user to use the ambiguous parameter\r\n        this._throwParserExitError(parserOptions, data, 1, `Ambiguous option: \"${parameterName}\".`);\r\n      }\r\n    }\r\n\r\n    // Fill in the values for the parameters\r\n    for (const parameter of this._parameters) {\r\n      const value: any = data[parameter._parserKey!]; // eslint-disable-line @typescript-eslint/no-explicit-any\r\n      parameter._setValue(value);\r\n    }\r\n\r\n    if (this.remainder) {\r\n      this.remainder._setValue(data[argparse.Const.REMAINDER]);\r\n    }\r\n\r\n    this._parametersHaveBeenProcessed = true;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _defineParameter(parameter: CommandLineParameter): void {\r\n    if (this._parametersHaveBeenRegistered) {\r\n      throw new Error('Parameters have already been registered for this provider');\r\n    }\r\n\r\n    // Generate and set the parser key at definition time\r\n    parameter._parserKey = this._generateKey();\r\n\r\n    this._parameters.push(parameter);\r\n\r\n    // Collect all parameters with the same long name. We will perform conflict resolution at registration.\r\n    let longNameParameters: CommandLineParameter[] | undefined = this._parametersByLongName.get(\r\n      parameter.longName\r\n    );\r\n    if (!longNameParameters) {\r\n      longNameParameters = [];\r\n      this._parametersByLongName.set(parameter.longName, longNameParameters);\r\n    }\r\n    longNameParameters.push(parameter);\r\n\r\n    // Collect all parameters with the same short name. We will perform conflict resolution at registration.\r\n    if (parameter.shortName) {\r\n      let shortNameParameters: CommandLineParameter[] | undefined = this._parametersByShortName.get(\r\n        parameter.shortName\r\n      );\r\n      if (!shortNameParameters) {\r\n        shortNameParameters = [];\r\n        this._parametersByShortName.set(parameter.shortName, shortNameParameters);\r\n      }\r\n      shortNameParameters.push(parameter);\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  protected _defineAmbiguousParameter(name: string): string {\r\n    if (this._parametersHaveBeenRegistered) {\r\n      throw new Error('Parameters have already been registered for this provider');\r\n    }\r\n\r\n    // Only generate a new parser key if the ambiguous parameter hasn't been defined yet,\r\n    // either as an existing parameter or as another ambiguous parameter\r\n    let existingParserKey: string | undefined =\r\n      this._registeredParameterParserKeysByName.get(name) ||\r\n      this._ambiguousParameterParserKeysByName.get(name);\r\n    if (!existingParserKey) {\r\n      existingParserKey = this._generateKey();\r\n    }\r\n\r\n    this._ambiguousParameterParserKeysByName.set(name, existingParserKey);\r\n    return existingParserKey;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _registerParameter(\r\n    parameter: CommandLineParameter,\r\n    useScopedLongName: boolean,\r\n    ignoreShortName: boolean\r\n  ): void {\r\n    const names: string[] = [];\r\n    if (parameter.shortName && !ignoreShortName) {\r\n      names.push(parameter.shortName);\r\n    }\r\n\r\n    // Use the original long name unless otherwise requested\r\n    if (!useScopedLongName) {\r\n      names.push(parameter.longName);\r\n    }\r\n\r\n    // Add the scoped long name if it exists\r\n    if (parameter.scopedLongName) {\r\n      names.push(parameter.scopedLongName);\r\n    }\r\n\r\n    let finalDescription: string = parameter.description;\r\n\r\n    const supplementaryNotes: string[] = [];\r\n    parameter._getSupplementaryNotes(supplementaryNotes);\r\n    if (supplementaryNotes.length > 0) {\r\n      // If they left the period off the end of their sentence, then add one.\r\n      if (finalDescription.match(/[a-z0-9]\"?\\s*$/i)) {\r\n        finalDescription = finalDescription.trimRight() + '.';\r\n      }\r\n      // Append the supplementary text\r\n      finalDescription += ' ' + supplementaryNotes.join(' ');\r\n    }\r\n\r\n    // NOTE: Our \"environmentVariable\" feature takes precedence over argparse's \"defaultValue\",\r\n    // so we have to reimplement that feature.\r\n    const argparseOptions: argparse.ArgumentOptions = {\r\n      help: finalDescription,\r\n      dest: parameter._parserKey,\r\n      metavar: (parameter as CommandLineParameterWithArgument).argumentName || undefined,\r\n      required: parameter.required\r\n    };\r\n\r\n    switch (parameter.kind) {\r\n      case CommandLineParameterKind.Choice: {\r\n        const choiceParameter: CommandLineChoiceParameter = parameter as CommandLineChoiceParameter;\r\n        argparseOptions.choices = choiceParameter.alternatives as string[];\r\n        break;\r\n      }\r\n      case CommandLineParameterKind.ChoiceList: {\r\n        const choiceParameter: CommandLineChoiceListParameter = parameter as CommandLineChoiceListParameter;\r\n        argparseOptions.choices = choiceParameter.alternatives as string[];\r\n        argparseOptions.action = 'append';\r\n        break;\r\n      }\r\n      case CommandLineParameterKind.Flag:\r\n        argparseOptions.action = 'storeTrue';\r\n        break;\r\n      case CommandLineParameterKind.Integer:\r\n        argparseOptions.type = 'int';\r\n        break;\r\n      case CommandLineParameterKind.IntegerList:\r\n        argparseOptions.type = 'int';\r\n        argparseOptions.action = 'append';\r\n        break;\r\n      case CommandLineParameterKind.String:\r\n        break;\r\n      case CommandLineParameterKind.StringList:\r\n        argparseOptions.action = 'append';\r\n        break;\r\n    }\r\n\r\n    let argumentGroup: argparse.ArgumentGroup | undefined;\r\n    if (parameter.parameterGroup) {\r\n      argumentGroup = this._parameterGroupsByName.get(parameter.parameterGroup);\r\n      if (!argumentGroup) {\r\n        let parameterGroupName: string;\r\n        if (typeof parameter.parameterGroup === 'string') {\r\n          parameterGroupName = parameter.parameterGroup;\r\n        } else if (parameter.parameterGroup === SCOPING_PARAMETER_GROUP) {\r\n          parameterGroupName = 'scoping';\r\n        } else {\r\n          throw new Error('Unexpected parameter group: ' + parameter.parameterGroup);\r\n        }\r\n\r\n        argumentGroup = this._getArgumentParser().addArgumentGroup({\r\n          title: `Optional ${parameterGroupName} arguments`\r\n        });\r\n        this._parameterGroupsByName.set(parameter.parameterGroup, argumentGroup);\r\n      }\r\n    } else {\r\n      argumentGroup = this._getArgumentParser();\r\n    }\r\n\r\n    argumentGroup.addArgument(names, { ...argparseOptions });\r\n\r\n    if (parameter.undocumentedSynonyms?.length) {\r\n      argumentGroup.addArgument(parameter.undocumentedSynonyms, {\r\n        ...argparseOptions,\r\n        help: argparse.Const.SUPPRESS\r\n      });\r\n    }\r\n\r\n    // Register the parameter names so that we can detect ambiguous parameters\r\n    for (const name of [...names, ...(parameter.undocumentedSynonyms || [])]) {\r\n      this._registeredParameterParserKeysByName.set(name, parameter._parserKey!);\r\n    }\r\n  }\r\n\r\n  protected _registerAmbiguousParameter(name: string, parserKey: string): void {\r\n    this._getArgumentParser().addArgument(name, {\r\n      dest: parserKey,\r\n      // We don't know if this argument takes parameters or not, so we need to accept any number of args\r\n      nargs: '*',\r\n      // Ensure that the argument is not shown in the help text, since these parameters are only included\r\n      // to inform the user that ambiguous parameters are present\r\n      help: argparse.Const.SUPPRESS\r\n    });\r\n  }\r\n\r\n  private _generateKey(): string {\r\n    return 'key_' + (CommandLineParameterProvider._keyCounter++).toString();\r\n  }\r\n\r\n  private _getParameter<T extends CommandLineParameter>(\r\n    parameterLongName: string,\r\n    expectedKind: CommandLineParameterKind,\r\n    parameterScope?: string\r\n  ): T {\r\n    // Support the parameter long name being prefixed with the scope\r\n    const { scope, longName } = this.parseScopedLongName(parameterLongName);\r\n    parameterLongName = longName;\r\n    parameterScope = scope || parameterScope;\r\n\r\n    const parameters: CommandLineParameter[] | undefined = this._parametersByLongName.get(parameterLongName);\r\n    if (!parameters) {\r\n      throw new Error(`The parameter \"${parameterLongName}\" is not defined`);\r\n    }\r\n\r\n    let parameter: CommandLineParameter | undefined = parameters.find(\r\n      (p) => p.parameterScope === parameterScope\r\n    );\r\n    if (!parameter) {\r\n      if (parameterScope !== undefined) {\r\n        throw new Error(\r\n          `The parameter \"${parameterLongName}\" with scope \"${parameterScope}\" is not defined.`\r\n        );\r\n      }\r\n      if (parameters.length !== 1) {\r\n        throw new Error(`The parameter \"${parameterLongName}\" is ambiguous. You must specify a scope.`);\r\n      }\r\n      parameter = parameters[0];\r\n    }\r\n\r\n    if (parameter.kind !== expectedKind) {\r\n      throw new Error(\r\n        `The parameter \"${parameterLongName}\" is of type \"${CommandLineParameterKind[parameter.kind]}\"` +\r\n          ` whereas the caller was expecting \"${CommandLineParameterKind[expectedKind]}\".`\r\n      );\r\n    }\r\n\r\n    return parameter as T;\r\n  }\r\n\r\n  private _throwParserExitError(\r\n    parserOptions: ICommandLineParserOptions,\r\n    data: ICommandLineParserData,\r\n    errorCode: number,\r\n    message: string\r\n  ): never {\r\n    // Write out the usage text to make it easier for the user to find the correct parameter name\r\n    const targetActionName: string = data.aliasAction || data.action || '';\r\n    const errorPrefix: string =\r\n      `Error: ${parserOptions.toolFilename}` +\r\n      // Handle aliases, actions, and actionless parameter providers\r\n      `${targetActionName ? ' ' : ''}${targetActionName}: error: `;\r\n\r\n    // eslint-disable-next-line no-console\r\n    console.log(this.renderUsageText());\r\n    throw new CommandLineParserExitError(errorCode, `${errorPrefix}${message.trimStart().trimEnd()}\\n`);\r\n  }\r\n}\r\n"]}