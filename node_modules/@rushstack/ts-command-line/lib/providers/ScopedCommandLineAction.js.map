{"version":3,"file":"ScopedCommandLineAction.js","sourceRoot":"","sources":["../../src/providers/ScopedCommandLineAction.ts"],"names":[],"mappings":"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","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved. Licensed under the MIT license.\r\n// See LICENSE in the project root for license information.\r\n\r\nimport { SCOPING_PARAMETER_GROUP } from '../Constants';\r\nimport { CommandLineAction, type ICommandLineActionOptions } from './CommandLineAction';\r\nimport { CommandLineParser, type ICommandLineParserOptions } from './CommandLineParser';\r\nimport { CommandLineParserExitError } from './CommandLineParserExitError';\r\nimport type { CommandLineParameter } from '../parameters/BaseClasses';\r\nimport type {\r\n  CommandLineParameterProvider,\r\n  ICommandLineParserData,\r\n  IRegisterDefinedParametersState\r\n} from './CommandLineParameterProvider';\r\n\r\ninterface IInternalScopedCommandLineParserOptions extends ICommandLineParserOptions {\r\n  readonly actionOptions: ICommandLineActionOptions;\r\n  readonly unscopedActionParameters: ReadonlyArray<CommandLineParameter>;\r\n  readonly onDefineScopedParameters: (commandLineParameterProvider: CommandLineParameterProvider) => void;\r\n  readonly aliasAction?: string;\r\n  readonly aliasDocumentation?: string;\r\n  readonly registerDefinedParametersState: IRegisterDefinedParametersState;\r\n}\r\n\r\n/**\r\n * A CommandLineParser used exclusively to parse the scoped command-line parameters\r\n * for a ScopedCommandLineAction.\r\n */\r\nclass InternalScopedCommandLineParser extends CommandLineParser {\r\n  private _canExecute: boolean;\r\n  private readonly _internalOptions: IInternalScopedCommandLineParserOptions;\r\n\r\n  public get canExecute(): boolean {\r\n    return this._canExecute;\r\n  }\r\n\r\n  public constructor(options: IInternalScopedCommandLineParserOptions) {\r\n    const { actionOptions, unscopedActionParameters, toolFilename, aliasAction, aliasDocumentation } =\r\n      options;\r\n\r\n    const toolCommand: string = `${toolFilename} ${actionOptions.actionName}`;\r\n    // When coming from an alias command, we want to show the alias command name in the help text\r\n    const toolCommandForLogging: string = `${toolFilename} ${aliasAction ?? actionOptions.actionName}`;\r\n    const scopingArgs: string[] = [];\r\n    for (const parameter of unscopedActionParameters) {\r\n      parameter.appendToArgList(scopingArgs);\r\n    }\r\n    const scope: string = scopingArgs.join(' ');\r\n\r\n    // We can run the parser directly because we are not going to use it for any other actions,\r\n    // so construct a special options object to make the \"--help\" text more useful.\r\n    const scopedCommandLineParserOptions: ICommandLineParserOptions = {\r\n      // Strip the scoping args if coming from an alias command, since they are not applicable\r\n      // to the alias command itself\r\n      toolFilename: `${toolCommandForLogging}${scope && !aliasAction ? ` ${scope} --` : ''}`,\r\n      toolDescription: aliasDocumentation ?? actionOptions.documentation,\r\n      toolEpilog: `For more information on available unscoped parameters, use \"${toolCommand} --help\"`,\r\n      enableTabCompletionAction: false\r\n    };\r\n\r\n    super(scopedCommandLineParserOptions);\r\n    this._canExecute = false;\r\n    this._internalOptions = options;\r\n    this._internalOptions.onDefineScopedParameters(this);\r\n  }\r\n\r\n  public _registerDefinedParameters(state: IRegisterDefinedParametersState): void {\r\n    // Since we are in a separate parser, we need to register the parameters using the state\r\n    // from the parent parser.\r\n    super._registerDefinedParameters(this._internalOptions.registerDefinedParametersState);\r\n  }\r\n\r\n  protected async onExecute(): Promise<void> {\r\n    // override\r\n    // Only set if we made it this far, which may not be the case if an error occurred or\r\n    // if '--help' was specified.\r\n    this._canExecute = true;\r\n  }\r\n}\r\n\r\n/**\r\n * Represents a sub-command that is part of the CommandLineParser command-line.\r\n * Applications should create subclasses of ScopedCommandLineAction corresponding to\r\n * each action that they want to expose.\r\n *\r\n * The action name should be comprised of lower case words separated by hyphens\r\n * or colons. The name should include an English verb (e.g. \"deploy\"). Use a\r\n * hyphen to separate words (e.g. \"upload-docs\"). A group of related commands\r\n * can be prefixed with a colon (e.g. \"docs:generate\", \"docs:deploy\",\r\n * \"docs:serve\", etc).\r\n *\r\n * Scoped commands allow for different parameters to be specified for different\r\n * provided scoping values. For example, the \"scoped-action --scope A\" command\r\n * may allow for different scoped arguments to be specified than the \"scoped-action\r\n * --scope B\" command.\r\n *\r\n * Scoped arguments are specified after the \"--\" pseudo-argument. For example,\r\n * \"scoped-action --scope A -- --scopedFoo --scopedBar\".\r\n *\r\n * @public\r\n */\r\nexport abstract class ScopedCommandLineAction extends CommandLineAction {\r\n  private _options: ICommandLineActionOptions;\r\n  private _scopingParameters: CommandLineParameter[];\r\n  private _unscopedParserOptions: ICommandLineParserOptions | undefined;\r\n  private _scopedCommandLineParser: InternalScopedCommandLineParser | undefined;\r\n  private _subparserState: IRegisterDefinedParametersState | undefined;\r\n\r\n  /**\r\n   * The required group name to apply to all scoping parameters. At least one parameter\r\n   * must be defined with this group name.\r\n   */\r\n  public static readonly ScopingParameterGroup: typeof SCOPING_PARAMETER_GROUP = SCOPING_PARAMETER_GROUP;\r\n\r\n  public constructor(options: ICommandLineActionOptions) {\r\n    super(options);\r\n\r\n    this._options = options;\r\n    this._scopingParameters = [];\r\n  }\r\n\r\n  /**\r\n   * {@inheritDoc CommandLineParameterProvider.parameters}\r\n   */\r\n  public get parameters(): ReadonlyArray<CommandLineParameter> {\r\n    if (this._scopedCommandLineParser) {\r\n      return [...super.parameters, ...this._scopedCommandLineParser.parameters];\r\n    } else {\r\n      return super.parameters;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * {@inheritdoc CommandLineAction._processParsedData}\r\n   * @internal\r\n   */\r\n  public _processParsedData(parserOptions: ICommandLineParserOptions, data: ICommandLineParserData): void {\r\n    // override\r\n    super._processParsedData(parserOptions, data);\r\n\r\n    // This should never happen because the super method should throw if parameters haven't been registered,\r\n    // but guard against this just in-case.\r\n    if (this._subparserState === undefined) {\r\n      throw new Error('Parameters have not been registered');\r\n    }\r\n\r\n    this._unscopedParserOptions = parserOptions;\r\n\r\n    // Generate the scoped parser using the parent parser information. We can only create this after we\r\n    // have parsed the data, since the parameter values are used during construction.\r\n    this._scopedCommandLineParser = new InternalScopedCommandLineParser({\r\n      ...parserOptions,\r\n      actionOptions: this._options,\r\n      aliasAction: data.aliasAction,\r\n      aliasDocumentation: data.aliasDocumentation,\r\n      unscopedActionParameters: this.parameters,\r\n      registerDefinedParametersState: this._subparserState,\r\n      onDefineScopedParameters: this.onDefineScopedParameters.bind(this)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * {@inheritdoc CommandLineAction._execute}\r\n   * @internal\r\n   */\r\n  public async _execute(): Promise<void> {\r\n    // override\r\n    if (!this._unscopedParserOptions || !this._scopedCommandLineParser) {\r\n      throw new Error('The CommandLineAction parameters must be processed before execution.');\r\n    }\r\n    if (!this.remainder) {\r\n      throw new Error('CommandLineAction.onDefineParameters must be called before execution.');\r\n    }\r\n\r\n    // The '--' argument is required to separate the action parameters from the scoped parameters,\r\n    // so it needs to be trimmed. If remainder values are provided but no '--' is found, then throw.\r\n    const scopedArgs: string[] = [];\r\n    if (this.remainder.values.length) {\r\n      if (this.remainder.values[0] !== '--') {\r\n        throw new CommandLineParserExitError(\r\n          // argparse sets exit code 2 for invalid arguments\r\n          2,\r\n          // model the message off of the built-in \"unrecognized arguments\" message\r\n          `${this.renderUsageText()}\\n${this._unscopedParserOptions.toolFilename} ${this.actionName}: ` +\r\n            `error: Unrecognized arguments: ${this.remainder.values[0]}.\\n`\r\n        );\r\n      }\r\n      for (const scopedArg of this.remainder.values.slice(1)) {\r\n        scopedArgs.push(scopedArg);\r\n      }\r\n    }\r\n\r\n    // Call the scoped parser using only the scoped args to handle parsing\r\n    await this._scopedCommandLineParser.executeWithoutErrorHandling(scopedArgs);\r\n\r\n    // Only call execute if the parser reached the execute stage. This may not be true if\r\n    // the parser exited early due to a specified '--help' parameter.\r\n    if (this._scopedCommandLineParser.canExecute) {\r\n      await super._execute();\r\n    }\r\n\r\n    return;\r\n  }\r\n\r\n  /** @internal */\r\n  public _registerDefinedParameters(state: IRegisterDefinedParametersState): void {\r\n    super._registerDefinedParameters(state);\r\n\r\n    const { parentParameterNames } = state;\r\n    const updatedParentParameterNames: Set<string> = new Set([\r\n      ...parentParameterNames,\r\n      ...this._registeredParameterParserKeysByName.keys()\r\n    ]);\r\n\r\n    this._subparserState = {\r\n      ...state,\r\n      parentParameterNames: updatedParentParameterNames\r\n    };\r\n  }\r\n\r\n  /**\r\n   * {@inheritdoc CommandLineParameterProvider.onDefineParameters}\r\n   */\r\n  protected onDefineParameters(): void {\r\n    this.onDefineUnscopedParameters?.();\r\n\r\n    if (!this._scopingParameters.length) {\r\n      throw new Error(\r\n        'No scoping parameters defined. At least one scoping parameter must be defined. ' +\r\n          'Scoping parameters are defined by setting the parameterGroupName to ' +\r\n          'ScopedCommandLineAction.ScopingParameterGroupName.'\r\n      );\r\n    }\r\n    if (this.remainder) {\r\n      throw new Error(\r\n        'Unscoped remainder parameters are not allowed. Remainder parameters can only be defined on ' +\r\n          'the scoped parameter provider in onDefineScopedParameters().'\r\n      );\r\n    }\r\n\r\n    // Consume the remainder of the command-line, which will later be passed the scoped parser.\r\n    // This will also prevent developers from calling this.defineCommandLineRemainder(...) since\r\n    // we will have already defined it.\r\n    this.defineCommandLineRemainder({\r\n      description:\r\n        'Scoped parameters.  Must be prefixed with \"--\", ex. \"-- --scopedParameter ' +\r\n        'foo --scopedFlag\".  For more information on available scoped parameters, use \"-- --help\".'\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Retrieves the scoped CommandLineParser, which is populated after the ScopedCommandLineAction is executed.\r\n   * @internal\r\n   */\r\n  protected _getScopedCommandLineParser(): CommandLineParser {\r\n    if (!this._scopedCommandLineParser) {\r\n      throw new Error('The scoped CommandLineParser is only populated after the action is executed.');\r\n    }\r\n    return this._scopedCommandLineParser;\r\n  }\r\n\r\n  /** @internal */\r\n  protected _defineParameter(parameter: CommandLineParameter): void {\r\n    super._defineParameter(parameter);\r\n    if (parameter.parameterGroup === ScopedCommandLineAction.ScopingParameterGroup) {\r\n      this._scopingParameters.push(parameter);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * The child class should implement this hook to define its unscoped command-line parameters,\r\n   * e.g. by calling defineFlagParameter(). At least one scoping parameter must be defined.\r\n   * Scoping parameters are defined by setting the parameterGroupName to\r\n   * ScopedCommandLineAction.ScopingParameterGroupName.\r\n   */\r\n  protected onDefineUnscopedParameters?(): void;\r\n\r\n  /**\r\n   * The child class should implement this hook to define its scoped command-line\r\n   * parameters, e.g. by calling scopedParameterProvider.defineFlagParameter(). These\r\n   * parameters will only be available if the action is invoked with a scope.\r\n   *\r\n   * @remarks\r\n   * onDefineScopedParameters is called after the unscoped parameters have been parsed.\r\n   * The values they provide can be used to vary the defined scope parameters.\r\n   */\r\n  protected abstract onDefineScopedParameters(scopedParameterProvider: CommandLineParameterProvider): void;\r\n\r\n  /**\r\n   * {@inheritDoc CommandLineAction.onExecute}\r\n   */\r\n  protected abstract onExecute(): Promise<void>;\r\n}\r\n"]}